.TH NEWREL 1-ucb
.SH ORIGIN
4.2BSD
.SH NAME
newrel \- create and initialise a new 
.I simc
relation
.SH SYNOPSIS
.B newrel
db rel type Br Bs Kr Ks Ur Us Nr Ns Nd Av skeleton
.SH DESCRIPTION
.I Newrel
creates a new relation called
.B rel
in the database called
.B db
according to the various parameters and initialises
all of the files which comprise the relation.
The parameters are quite complex and are described only
briefly here; for more details consult the (soon to appear)
.I simc
tutorial (or better still, have a look at some examples).
In general, it is easier to use
.I dbparams
to generate the full set of parameters from a simple subset
(however, the 
.I skeleton
must still be generated by hand).
A typical usage might be as follows:
.TP
	\fBnewrel\fP db rel type `\|dbparams args .\|.\|.\|` skel
.PP
The parameters are as follows:
.TP 4
.B db
Name of database. Specifies a directory where the relations
reside.
.TP 4
.B rel
Name of relation. Usually resembles a C identifier, but can be any
arbitrary string (e.g. ``employee'', ``+'', ``:-'').
It also specifies a directory containing the index and data files.
.TP 4
.B type
The type of indexing scheme to use. At present there are only two
possibilities: ``simc'' for the standard superimposed codeword scheme,
and ``dsimc'' for a dynamic superimposed codeword scheme (not yet
fully implemented).
.TP 4
.B Br
Number of bits in record descriptors. In general, the larger this
is, the more accurate will be the indexing scheme.
.TP 4
.B Bs
Number of bits in segment descriptors.
.TP 4
.B Kr
Number of bits to set in record descriptor for each key.
.I nkeys
*
.B Kr
gives the total number of bits to set in the record descriptor
for each record.
The smaller 
.B Kr
is relative to
.B Br
the more accurate will be the indexing scheme.
.TP 4
.B Ks
Number of bits to set in record descriptor for each key.
.TP 4
.B Ur
Number of bits in record descriptor to use
when generating record matches.
Must be less than
.I nkeys
*
.BR Kr ,
and is often simply equal to
.BR Kr .
There is an optimal value for this parameter. If it too small,
then the indexing will not be accurate enough, and more
.I false matches
may occur.
If it is too large, the number of AND and OR operations which
need to be done on large descriptors, makes querying more expensive.
.TP 4
.B Us
Number of bits in record descriptor to use
when generating segment matches.
.TP 4
.B Nr
Maximum records stored in each segment.
.TP 4
.B Ns
Maximum segments in relation.
The product,
.B Ns
*
.BR Nr ,
gives the maximum number of records which can be stored in the relation.
If this is exceeded, then massive re-organisation of the database is
necessary. At present, this is not implemented, so relations have a fixed
maximum size.
.TP 4
.B Nd
The number of data files to use to store the segments of the relation.
Initially, for locking, the system aimed to have one file per segment,
but since large databases require more than 1000 segments this is not
feasible.
There is a trade-off here between speed and locking; sixteen files is
sufficient for around 1000 segments.
.TP 4
.B Av
Average length of records. Records are stored simply as C-like text
strings within the segments, with the relation name stripped off.
Thus the record
.br
	``employee(e1234,fred,analyst,edp,30000)''
.br
will be stored in the data file as
.br
	``e1234,fred,analyst,edp,30000''.
.br
Note that this does not form a fixed upper bound;
it is possible to exceed average length
at a cost in retrieval performance.
.TP 4
.B skeleton
Describes the structure and properties of the keys in the relation.
The structure resembles a prefix notation functional expression,
with the arguments being descriptors of the following form:
.sp
	var_flag\fB:\fPweight\fB:\fPcluster_mask
.br
.sp
The
.I var_flag
field is `g' if that component can never be variable (i.e.
is always ground) in the
database (this saves time in performing queries), or `v' if
records containing variables in this position may exist.
.sp
The
.I weight
field is an integer which indicates how likely this field
is to be specified in queries; the most heavily used fields
are given the highest values. The values are scaled by the
system to give the number of bits to set.
.sp
The
.I cluster_mask
is a bit string, written as a hexadecimal number, which tells
which bits to use to generate the segment number during insertion.
Keys whose values have a high frequency of repetition should
be allocated the most bits.
It is not desirable to have overlaps in the bit strings for
different fields, but the system does not check this.
.sp
In the employee example above, a suitable
.I skeleton
would be:
.sp
	g:0:0(g:4:0,g:6:01,g:3:6c,g:3:12,g:1:80)
.SH FILES
db/rel/desc	Index files
.br
db/rel/00*	Data files
.SH SEE ALSO
ddb(1), consult(1), dbinfo(1), dbparams(1), prefix(1)
.SH DIAGNOSTICS
Silent bastardry.
.SH BUGS
Who KNOWS where the bugs are?
